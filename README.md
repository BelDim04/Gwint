# Gwint
Gwint project TP edu

1)Основой кода является абстрактный класс Card. Вне реализации этого класса(и его наследников) весь код работает только с классом Card. У каждого элемента этого класса есть поля имя карточки(воин, Эльф, Стрыга и т.д.), строка, соответсвующая файлу с картинкой к этой карточке, а также строка, соответствующая расположению карты в игре. Есть метод set_where_lies(Game& game), который задаёт карточке её местоположение. Есть метод use_special_ability(Game& game). Этот метод использует уникальную способность карты - например, лекарь возвращает к живым одного из погибших уже товарищей. У Card есть наследник Strength_card. У каждого элемента этого класса есть поля, соответствующие разным её характеристикам
(подробнее можно почитать в самом коде), а также есть метод recalculate(Game& game) - пересчитать силу карты в данной игре.

2)Также есть класс Game. Этот класс отвечает за всю внутреннюю логику игры. В классе Game есть 2 поля класса Player. Класс Player состоит из нескольких массивов карт(часть из этого массива находится в поле класса Desk. В нём лежат все массивы выложенных на стол карт). Всего этих массивов 9 - 3 отвечают за выложенные на поле карты силы, 3 за выложенные карты баффа, один за массив карт, который есть у игрока в руке, один за массив сброса, один за массив запаса колоды. В классе Game также есть объект класса Weather_manager, отвечающий за погоду и её менеджмент. В классе Game есть методы now_moving(), not_now_moving(), str_now_moving(), str_not_now_moving(), возвращающие ссылку на игрока/строку имени игрока, который ходит/не ходит сейчас. Есть метод recalculate(), который пересчитывает силы всех карт. Метод find_vector(string) по расположению карты возвращает ссылку на вектор, в котором она лежит. Метод is_weather_bad(string) и find_weather_buffer по расположению карты понимает, плохая ли погода. Методы spy_move и healing_move помогают реализовать уникальные способности шпиона и лекаря. Find_buffer по расположению карты возвращает пару чисел, отвечающих за бафф карт. Now_moving_hp возвращает хп игрока, который сейчас ходит. Метод maketurn(int) по номеру карты в руке кладёт эту карту на стол. is_round_ended() возвращает, закончен ли раунд, on_round_ended() убирает все карты с доски в сброс. 

3)Добавлены класс Animation и класс TextureHolder, отвечающие за отображение всех компогнент игры. В классе TextureHolder хранятся все текстуры, метод Load загружает их в TextureHolder, get помогает их получить. В классе Animation есть поле game GameLogic - игра, которую запускаем, sf::RenderWindow window-соотвтественно окно, TextureHolder textureholder-поле, где хранима текстуры, std::vector<sf::Sprite> clickSprites - вектор текстур(карточек) на которые можно нажать. Метод run - главный цикл игры.
Он состоит из методов render, processEvents и update. ProcessEvents меняет внутреннюю логику в зависимости от действий игрока, render отрисовывает игру в зависимости от внутренней логики. Update отвечает за конец раунда и конец игры. Метод show_line_of_cards(const std::vector<Card*>& cards, size_t start_x, size_t end_x, size_t y, bool clickable) выводит массив карт на соответствующие координаты.

4)Есть файлы Card_src.h, Player_decks.h, Bot_decks.h. В первом хранятся все образцы карточек, во втором шаблоны колод игроков, в третьем шаблоны колод ботов.

5)Есть файл src. В нём хранятся все изображения, которые используются в текстурах.

6)Как запустить проект? Нужно создать проект, скопировать туда все файлы, скопировать туда папку src и запустить его с данным CMake.
